[]()> [!abstract] Непрерывная интеграция и доставка
> Автоматизация процессов сборки, тестирования и развертывания программного обеспечения для повышения качества и скорости разработки.

---

## 1. Почему нужна CI/CD автоматизация?

```mermaid
graph TD
    A[Ручные процессы] -->|Проблемы| B[Ошибки человеческого фактора]
    A -->|Проблемы| C[Медленная доставка]
    A -->|Проблемы| D[Непоследовательность окружений]
    
    E[CI/CD Автоматизация] -->|Преимущества| F[Быстрая обратная связь]
    E -->|Преимущества| G[Снижение рисков]
    E -->|Преимущества| H[Повторяемость процессов]
    E -->|Преимущества| I[Освобождение разработчиков]
```

**Ключевые причины для CI/CD:**

| Проблема без CI/CD | Решение с CI/CD |
|-------------------|-----------------|
| **"У меня работает на машине"** | Стандартизированные окружения |
| **Ручное тестирование занимает часы/дни** | Автоматические тесты за минуты |
| **Ошибки обнаруживаются поздно** | Раннее обнаружение проблем |
| **Страх деплоить по пятницам** | Частые, маленькие, безопасные деплои |
| **Разработчики тратят время на рутину** | Фокус на разработке, а не операциях |

> [!quote] Философия CI/CD
> "Если что-то нужно делать больше одного раза — автоматизируйте это."

---

## 2. Что означает CI?
**CI (Continuous Integration — Непрерывная интеграция)** — практика частого слияния изменений всех разработчиков в основную ветку с автоматической проверкой каждой интеграции.

**Основные принципы CI:**
- **Частые коммиты** в общую ветку (минимум раз в день)
- **Автоматическая сборка** при каждом пуше
- **Автоматическое тестирование** всех изменений
- **Быстрая обратная связь** о проблемах
- **Готовность main ветки** к деплою в любой момент

```mermaid
sequenceDiagram
    participant D as Developer
    participant R as Git Repo
    participant CI as CI Сервер
    participant N as Уведомления
    
    D->>R: Push изменений
    R->>CI: Триггер сборки
    CI->>CI: Выполняет сборку
    CI->>CI: Запускает тесты
    alt Тесты пройдены
        CI->>N: ✅ Успешная сборка
        CI->>R: Обновляет статус
    else Тесты упали
        CI->>N: ❌ Сборка упала
        CI->>D: Сообщение об ошибке
        D->>D: Исправляет ошибки
    end
```

---

## 3. Что означает CD?
**CD (Continuous Delivery/Deployment — Непрерывная доставка/развертывание)** — практика автоматического развертывания проверенного кода в различные окружения.

**Два значения CD:**
1. **Continuous Delivery** — код всегда готов к ручному развертыванию
2. **Continuous Deployment** — код автоматически развертывается после успешного CI

```mermaid
graph LR
    A[Код] --> B[CI: Сборка и тесты]
    B --> C{Все проверки пройдены?}
    
    C -->|Да: Continuous Delivery| D[Готов к деплою<br/>Ждет ручного подтверждения]
    D --> E[Ручной деплой в прод]
    
    C -->|Да: Continuous Deployment| F[Автоматический деплой в прод]
    
    C -->|Нет| G[Отклонено<br/>Требует исправлений]
```

**Различия:**
- **Delivery** = автоматически до production-like среды, ручной деплой в прод
- **Deployment** = полностью автоматически до production

---

## 4. Какими инструментами CI/CD мы пользовались в течение семестра

| Инструмент | Тип | Использование в курсе |
|------------|-----|----------------------|
| **GitHub Actions** | Cloud CI/CD | Основной инструмент для домашних работ |
| **GitVerse Actions** | Cloud CI/CD | Альтернатива/дополнение к GitHub |
| **Docker** | Контейнеризация | Создание воспроизводимых окружений |
| **YAML** | Язык конфигурации | Описание workflow'ов |
| **Makefile** | Автоматизация сборки | Локальная автоматизация задач |

**Типичный стек в курсе:**
```yaml
# GitHub/GitVerse Actions workflow
# ↓
# Docker контейнер с окружением
# ↓
# Python/Node.js приложение
# ↓
# Автоматические тесты (pytest/jest)
# ↓
# Деплой на test/staging сервер
```

---

## 5. Назовите основные блоки YAML файла для GitHub/GitVerse Actions workflow.

```yaml
# БЛОК 1: Имя workflow
name: CI Pipeline

# БЛОК 2: Триггеры (когда запускаться)
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # Ежедневно в 2:00

# БЛОК 3: Переменные окружения
env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'

# БЛОК 4: Jobs (задачи)
jobs:
  # БЛОК 4.1: Job 1 - Тестирование
  test:
    # БЛОК 4.1.1: Конфигурация runner'а
    runs-on: ubuntu-latest
    
    # БЛОК 4.1.2: Шаги выполнения
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Run tests
        run: npm test
  
  # БЛОК 4.2: Job 2 - Сборка
  build:
    runs-on: ubuntu-latest
    needs: test  # Зависимость от job test
    steps:
      - name: Build Docker image
        run: docker build -t myapp .
```

**Структурная схема:**
```mermaid
graph TD
    A[name] --> B[on: Триггеры]
    A --> C[env: Переменные]
    A --> D[jobs: Задачи]
    
    D --> E[job1: test]
    D --> F[job2: build]
    D --> G[job3: deploy]
    
    E --> H[runs-on: Окружение]
    E --> I[steps: Шаги]
    
    I --> J[Шаг 1: Checkout]
    I --> K[Шаг 2: Setup]
    I --> L[Шаг 3: Run]
```

---

## 6. Где как правило хранится файл с описанием действий

**Стандартная структура:**
```
project-root/
├── .github/           # Папка для GitHub Actions
│   └── workflows/     # Все workflow файлы
│       ├── ci.yml     # Основной workflow
│       ├── deploy.yml # Деплой workflow
│       └── lint.yml   # Линтинг workflow
├── src/               # Исходный код
├── tests/             # Тесты
└── README.md
```

**Для GitVerse (аналогично):**
```
project-root/
├── .gitverse/         # Или аналогичная папка
│   └── workflows/     # Workflow файлы
│       └── pipeline.yml
└── ...
```

> [!important] Конвенция
> Workflow файлы хранятся в специальной директории `.github/workflows/` (для GitHub) или аналогичной для других платформ.

---

## 7. Какое название этого файла для домашних работ

**Типичные naming conventions для домашних работ:**

```yaml
# Универсальный вариант
ci.yml  # или
pipeline.yml

# Более специфичные (в зависимости от задачи)
test-and-build.yml
deploy-to-vercel.yml
check-homework.yml
hw1-ci.yml
hw2-autograde.yml

# Пример из реальных домашних работ
.github/workflows/
├── python-ci.yml          # Для Python проектов
├── nodejs-ci.yml          # Для Node.js проектов
├── docker-build.yml       # Для Docker проектов
└── autograde.yml          # Для автоматической проверки
```

**Рекомендации:**
- Используйте понятные имена
- Указывайте язык/технологию в названии
- Для разных домашних работ — разные файлы
- Используйте kebab-case: `my-workflow.yml`, а не `myWorkflow.yml`

---

## 8. На какие события может реагировать workflow?

```yaml
on:
  # 1. События Git
  push:                    # При пуше в репозиторий
    branches: [main]       # Ветки
    tags: [v*]            # Теги
  
  pull_request:            # При создании/обновлении PR
    types: [opened, synchronize]
    branches: [main]
  
  # 2. События Issues
  issues:
    types: [opened, labeled]
  
  # 3. События Projects
  project_card:
    types: [created, moved]
  
  # 4. Ручной запуск
  workflow_dispatch:       # Запуск через UI/API
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
  
  # 5. Расписание (cron)
  schedule:
    - cron: '0 0 * * *'   # Ежедневно в полночь
  
  # 6. События репозитория
  repository_dispatch:     # Внешние события через API
    types: [deploy]
  
  # 7. События других workflow
  workflow_run:            # При завершении другого workflow
    workflows: ["Tests"]
    types: [completed]
```

**Наиболее используемые:**
1. **`push`** — основной триггер для CI
2. **`pull_request`** — обязателен для code review
3. **`workflow_dispatch`** — для ручного запуска
4. **`schedule`** — для периодических задач (ночные сборки)

---

## 9. Что такое job в workflow?

**Job** — это набор шагов (steps), которые выполняются на одном runner'е. Jobs могут:
- Запускаться параллельно или последовательно
- Иметь зависимости друг от друга
- Выполняться на разных runner'ах
- Иметь разное окружение

```yaml
jobs:
  # Job 1: Линтинг и проверка кода
  lint:
    runs-on: ubuntu-latest
    steps: [...]
  
  # Job 2: Тестирование (зависит от lint)
  test:
    runs-on: ubuntu-latest
    needs: lint  # Зависимость
    steps: [...]
  
  # Job 3: Сборка (параллельно с test)
  build:
    runs-on: ubuntu-latest
    steps: [...]
  
  # Job 4: Деплой (только после успеха всех)
  deploy:
    runs-on: ubuntu-latest
    needs: [lint, test, build]  # Множественные зависимости
    if: github.ref == 'refs/heads/main'  # Условие выполнения
    steps: [...]
```

```mermaid
graph TD
    A[Push/PR] --> B[lint job]
    A --> C[test job]
    A --> D[build job]
    
    B --> E{Все успешно?}
    C --> E
    D --> E
    
    E -->|Да| F[deploy job]
    E -->|Нет| G[Workflow failed]
```

---

## 10. Что такое step в workflow?

**Step** — это отдельная задача в рамках job. Каждый step может быть:
1. **Командой shell** (`run:`)
2. **Действием из marketplace** (`uses:`)

```yaml
steps:
  # Шаг 1: Checkout кода (действие из marketplace)
  - name: Checkout repository
    uses: actions/checkout@v3
    with:
      fetch-depth: 0  # Параметры действия
  
  # Шаг 2: Настройка Python (действие)
  - name: Setup Python
    uses: actions/setup-python@v4
    with:
      python-version: '3.10'
  
  # Шаг 3: Установка зависимостей (shell команда)
  - name: Install dependencies
    run: |
      pip install -r requirements.txt
      pip install pytest
  
  # Шаг 4: Запуск тестов (shell команда)
  - name: Run tests
    run: pytest tests/ --cov=src
  
  # Шаг 5: Загрузка артефактов (действие)
  - name: Upload coverage report
    uses: actions/upload-artifact@v3
    with:
      name: coverage-report
      path: coverage.xml
```

**Ключевые атрибуты step:**
- `name:` — человекочитаемое описание
- `id:` — уникальный идентификатор для reference
- `if:` — условие выполнения
- `env:` — переменные окружения для шага
- `timeout-minutes:` — таймаут выполнения

---

## 11. Что такое runner в GitHub/GitVerse Actions?

**Runner** — это сервер (виртуальная машина), который выполняет jobs из workflow. 

**Типы runner'ов:**

| Тип | Описание | Использование |
|-----|----------|---------------|
| **GitHub-hosted** | Управляемые GitHub VM | Бесплатно для публичных репозиториев |
| **Self-hosted** | Ваши собственные серверы | Для специфичных требований |
| **Larger runners** | Больше CPU/RAM | Для ресурсоемких задач |

**Конфигурация runner'а:**
```yaml
jobs:
  build:
    # GitHub-hosted runner
    runs-on: ubuntu-latest  # Ubuntu 22.04
    
  test-windows:
    # Другая ОС
    runs-on: windows-latest
    
  test-matrix:
    # Матрица runner'ов
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16, 18, 20]
```

**Self-hosted runner (ваш сервер):**
```yaml
deploy-production:
  runs-on: [self-hosted, linux, x64, production]
  steps: [...]
```

---

## 12. Что означает `runs-on: ubuntu-latest` и когда выбрать другую ОС?

**`runs-on: ubuntu-latest`** означает, что job будет выполняться на последней доступной версии Ubuntu, предоставляемой GitHub.

**Доступные варианты ОС:**
```yaml
runs-on: ubuntu-latest    # Ubuntu 22.04 (на момент 2024)
runs-on: ubuntu-22.04     # Конкретная версия
runs-on: ubuntu-20.04     # Более старая LTS
runs-on: windows-latest   # Windows Server 2022
runs-on: windows-2019     # Конкретная версия Windows
runs-on: macos-latest     # macOS 13 Ventura
runs-on: macos-12         # macOS Monterey
```

**Когда выбирать другую ОС:**

| ОС | Когда использовать | Пример использования |
|----|-------------------|---------------------|
| **Ubuntu** | По умолчанию, для большинства задач | Веб-приложения, Python, Node. Js |
| **Windows** | .NET разработка, PowerShell скрипты | C #/ . NET проекты, Windows-специфичное тестирование |
| **macOS** | iOS/macOS разработка, Xcode проекты | React Native, Swift, Xcode builds |
| **Self-hosted** | Специфичные требования | GPU для ML, приватные сети, кастомное ПО |

**Матрица для кроссплатформенного тестирования:**
```yaml
test:
  strategy:
    matrix:
      os: [ubuntu-latest, windows-latest, macos-latest]
      python-version: ['3.9', '3.10', '3.11']
  runs-on: ${{ matrix.os }}
  steps:
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
```

---

## 13. Какие основные ошибки при написании CI/CD конфига?

### Ошибка 1: Некорректный YAML синтаксис
```yaml
# ❌ Неправильно (отсутствуют отступы)
steps:
- name: Test
run: npm test  # ОШИБКА: должен быть отступ

# ✅ Правильно
steps:
  - name: Test
    run: npm test
```

### Ошибка 2: Не указаны зависимости между jobs
```yaml
# ❌ Неправильно (deploy может запуститься до тестов)
jobs:
  test:
    steps: [...]
  deploy:
    steps: [...]  # ОШИБКА: нет needs: test

# ✅ Правильно
jobs:
  test:
    steps: [...]
  deploy:
    needs: test  # Зависимость от job test
    steps: [...]
```

### Ошибка 3: Секреты в логах
```yaml
# ❌ Неправильно (секрет будет виден в логах)
steps:
  - name: Deploy
    run: |
      echo "Deploying with key: MY_SECRET_KEY"
      # Секрет попадет в логи!

# ✅ Правильно (использование secrets)
steps:
  - name: Deploy
    env:
      API_KEY: ${{ secrets.DEPLOY_KEY }}
    run: |
      echo "Deploying..."
      # $API_KEY безопасен
```

### Ошибка 4: Отсутствие кэширования зависимостей
```yaml
# ❌ Неправильно (медленно, каждый раз качает зависимости)
steps:
  - name: Install dependencies
    run: npm ci  # Всегда полная установка

# ✅ Правильно (кэширование ускоряет сборки)
steps:
  - name: Cache dependencies
    uses: actions/cache@v3
    with:
      path: node_modules
      key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
```

### Ошибка 5: Неправильные условия выполнения
```yaml
# ❌ Неправильно (deploy запускается для всех PR)
deploy:
  if: github.event_name == 'push'  # Но также срабатывает для PR!

# ✅ Правильно
deploy:
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
```

---

## 14. Почему нельзя хранить пароли в YAML workflow'е в открытом виде?

**Причины безопасности:**

| Риск | Последствия |
|------|-------------|
| **Публичный репозиторий** | Любой может увидеть пароли |
| **История Git** | Даже если удалить — останется в истории |
| **Доступ сотрудников** | Не все должны иметь доступ к продакшен секретам |
| **Аккаунт скомпрометирован** | Злоумышленник получит все пароли |
| **Ротация паролей** | Сложно менять пароли, зашитые в код |

**Реальные примеры утечек:**
```yaml
# ❌ КАТАСТРОФА — пароль в открытом виде
env:
  DATABASE_PASSWORD: "SuperSecret123!"  # Увидят ВСЕ
  AWS_ACCESS_KEY: "AKIAIOSFODNN7EXAMPLE"
```

```bash
# История Git сохранит секреты НАВСЕГДА
git log -p workflow.yml  # Покажет все старые версии с секретами
```

**Лучшие практики:**
1. **Никогда не коммитьте секреты**
2. **Используйте встроенные механизмы secrets**
3. **Используйте внешние менеджеры секретов** (HashiCorp Vault, AWS Secrets Manager)
4. **Регулярно ротируйте секреты**

---

## 15. Как использовать secrets для хранения API ключей в workflow?

### Способ 1: Через GitHub/GitVerse Secrets UI
**Настройка:**
1. Settings → Secrets and variables → Actions → New repository secret
2. Добавить: `Name = API_KEY`, `Value = your-actual-key`
3. Сохранить

**Использование в workflow:**
```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in environment
        env:
          MY_API_KEY: ${{ secrets.API_KEY }}  # Безопасное использование
        run: |
          echo "Key is securely stored"
          # $MY_API_KEY доступен как переменная окружения
      
      - name: Use secret directly in command
        run: |
          curl -H "Authorization: Bearer ${{ secrets.API_KEY }}" \
               https://api.example.com/data
```

### Способ 2: Входные параметры для workflow_dispatch
```yaml
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy environment'
        required: true
        default: 'staging'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to ${{ github.event.inputs.environment }}
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          echo "Deploying to ${{ github.event.inputs.environment }}"
          # Используем $DEPLOY_KEY
```

### Способ 3: Маскирование секретов в логах
GitHub автоматически маскирует значения secrets в логах:
```yaml
steps:
  - name: Test secret masking
    run: |
      echo "Secret is: ${{ secrets.MY_SECRET }}"
      # В логах будет: "Secret is: ***"
```

### Способ 4: Организация секретов
```yaml
Env:
  # Переменные окружения для всех jobs
  NODE_ENV: production
  
Jobs:
  Test:
    Env:
      # Job-specific переменные
      TEST_DB_PASSWORD: $ {{ secrets.TEST_DB_PASSWORD }}
    
    Steps:
      - Name: Step with secret
        Env:
          # Step-specific секрет
          STEP_SECRET: $ {{ secrets.ANOTHER_SECRET }}
        Run: echo "Using secret at step level"
```

### Способ 5: Использование внешнего менеджера секретов
```yaml
Steps:
  - Name: Get secrets from AWS Secrets Manager
    Env:
      AWS_ACCESS_KEY_ID: $ {{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: $ {{ secrets.AWS_SECRET_ACCESS_KEY }}
    Run: |
      # Получаем секреты из AWS
      Aws secretsmanager get-secret-value \
        --secret-id production/database \
        --query SecretString --output text > db-secrets. Json
```

> [!warning] Важные правила работы с секретами
> 1. **Минимальные привилегии** — давайте секретам только необходимые права
> 2. **Ротация** — регулярно меняйте секреты
> 3. **Аудит** — отслеживайте использование секретов
> 4. **Разделение по окружениям** — разные секреты для dev/staging/prod
> 5. **Никогда не логируйте секреты** даже случайно

---

> [!summary] Итоговые выводы
> 1. **CI/CD** — обязательная практика для современной разработки
> 2. **YAML** — стандартный язык для описания workflow'ов
> 3. **GitHub/GitVerse Actions** — мощные инструменты с богатой экосистемой
> 4. **Структура workflow**: `on:` → `jobs:` → `steps:`
> 5. **Безопасность** — критически важна, особенно при работе с секретами

